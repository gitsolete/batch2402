batch2402@awco.in
salesforce12345

Apex Architecture
Variables 
Datatypes
Controlflow statements


Automation - programs - Data 

Variables - address ofthe memory location 
<datatype> <variablename>=<value>;

String studentName='Sravani';
String studentPhone='64654664';
String studentAddress='hydere';
Integer studentRollno=1002;


Datatypes  
	Integer - numbers [0-9]
	String - every character in keyboard
	double - 123.45
	Date - 
	Datetime - 
	Id - recordid
	boolean - True/False
	blob
Integer, Double, Long, Date, Datetime, String, ID, or Boolean 
non primitive Dt 
	salesforce objects 
	
	
how to display log information / 
System.debug('Student name::sravani');
system.debug('course::salesforce');
system.debug('phone::464646');
system.debug('address::hyderabad');


String studentName='Sravani';
Integer stdrollNo=104;
String stdAddress='hyd',stdphone='54646464';
System.debug('Student name=='+studentname);
system.debug('student rollno=='+stdrollNo);
system.debug('student address::'+stdaddress);
system.debug('student phone-->'+stdphone);


Operators
Assignment 
	=,+=,-=,*=
	
conditional operators true/false 
	<,>,<=,>=,!=,==
	
	left variable/value > right variable/value 
		5>6  = false
		5>=6 = false
		6>=6 = true 
		
		a>b , a==b 
	
Logical
	&&, ||
	and OR
T T T T
T F F T
F T F T
F F T F 
	complex conditions 
	
increment and decrement 
++
--

Ternary operator 
 ?:
 condition?True:false 
	
airthmatic operators 
 +,-,*,/
 
 
Integer a=0;
system.debug(a);
a=a+1; // a=0+1;  1
system.debug(a);
a+=2; //a=a+2;
system.debug(a);
a++;  //a=a+1;
system.debug(a);




//w.a.p to find the big value a and b
//input a,b
integer a=52,b=6,c,j,k;
integer res;
System.debug(a>b?'a is big':'b is big');

String result=a>b?'a is big':'b is big';
system.debug(result);

res=a>b?a:b;
system.debug(res);

//w.a.p to find the big value a and b and c
//input a,b,c
integer a=52,b=678,c=90,j,k;
string result=(a>b && a>c) ? 'a is big' : (b>a && b>c)?'b is big':'c is big';
system.debug(result);

//w.a.p to find the big value a and b and c
//input a,b,c
integer a=2,b=2,c=2,j,k;
string result=(a>b && a>c) ? 'a is big' : (b>a && b>c)?'b is big':(c>a && c>b)?'c is big':'all equal';
system.debug(result);


Integer productcode=5555;
string productname='laptop';
boolean isinstock=True;
Decimal unitprice=4000;
Date manufacturedate=system.today();
Date expirydate=system.Today().Adddays(90);
	//Date.newinstance(yyyy,mm,dd)

system.debug('product code::'+productcode);
system.debug('product name::'+productname);
system.debug('jisinstock::'+isinstock);
system.debug('unitprice::'+unitprice);
system.debug('manufaccture date::'+manufacturedate);
system.debug('expiry date::'+expirydate);


sobject datatype 
	Account  acc;
	Contact  con;
	orders    ord;
	student__c  stdp;
	
	
w.ap to calculate simpleinterest
ptr/100

input variable   - p,t, r
output varaibles - intamount
Integer intamount, principle,tenure,roi;
principle=100000;
tenure=5;
roi=10;
intamount=principle*tenure*roi/100;
system.debug('interest amount::'+intamount);



wap to calucllate bill amont basedon quantity and unitprice 
ip - quantity, unitprice
op - totalbill
Decimal unitprice=100.5,quantity=5,totalbill=unitprice*quantity;
system.debug('total bill amount::'+totalbill);


MVC architecture 
	m =model (database schema)
	v = view (UI, frontend / vf pages, html,css)
	c = controller (business logic standard logics, custom logic)
	
	
Control flow statements 
	
if condition
switch 
ternary operator
while
for 
foreach


Condiitiona 
if condition 

syntax 
	if(condition){
		//block of code
	}
	
if(constion){
 //true block
}
else{
//false block
}

//wap airthmatic operations
integer a,b,c;
a=10;b=0;c=0;

system.debug('sum of two numbers::'+(a+b));
c=a*b;
system.debug('multiplication ::'+c);
system.debug('substraction::'+(a-b));
if(b!=0){
  system.debug('division ::'+(a/b));  
}else{
    system.debug('b value should not be zero');
}


wap to define the rank class based on the total marks 
ip- t,m,e,s,so
calculations - totalmarks
op - resultclass
greaterthan 580 - frist class 
greaterthan 500 and lessthan 580 - second class 
greaterthan 450 and lessthan 500 - third class 



wap to find big among a,b,c
integer a=5,b=5,c=5;

if(a>b && a>c){
    system.debug('a isbig');
}
else if(b>a && b>c){
    system.debug('b is big');
}
else if(c>a && c>b){
    system.debug('c is big');
}
else{
    system.debug('all are equal');
}

wap to define the season 
monthno				sesaon name
1-4					winter
5-8					summer
9-12				spring
<1 or >12			invalid moonth number 


ip : monthno   - integer 
op : seasonname - string 


integer mn=5;
string sn;
system.debug(mn);
system.debug(sn);

if(mn>0&&mn<=4){
    sn='winter';
}
else if(mn>4&&mn<=8){
    sn='summer';
}
else if(mn>8&&mn<=12){
    sn='spring';
}
else{
    sn='not a valid month number';
}
system.debug('season name:'+sn);


nested if 

if(condition){
	if(condition){
	}
	else{
		if(condition){
		}		
	}
}else{
}



SWITCH statement
-----------------
switch on <expression>
{
	when <value>{}
	when <value>{}
	when <value>{}
	wher else{
	
	}
}


integer mn=5;
string sn;
switch on mn{
    when 1,2,3,4{
        sn='winer';
    }
    when 5,6,7,8{
        sn='summer';
    }
    when 9,10,11,12{
        sn='spring';
    }
    when else{
        sn='invalid month';
    }
}
system.debug('seasonname::::::'+sn);


Iterative statement
-------------------
while
do-while
for
enhanced for (for each) 



while(condition){

//block

}

do-while
do{
//block 
}while(condition);



wap toprint odd numbers 
wap to print even numbers 
wap to print prime numbers
wap to check the given numbe is prime number or not 
wap to swap the values
wap find lcm 


integer stid=100,stdid2=101,stdid3=102; 
stdid=100;
stdid=101;

ARRAYS
-------
collection of homogeneous elements 
static memory allocation

<datatype>[] variablename=new <datatype>[size];

integer[] stdid=new integer[10];
string[] stdname=new string[10];
id[] recordids=new id[10];
Account[] accountarray=new Account[30];
lead[] leadarray=new lead[20];
opportunity[] opparray=new opportunity[24];
hiringmanager__c[] hmgrarray=new hiringmanager__c[20];
position__c[] positionarray=new position__c[20];
student__c[] stdarray=new student__c[34];



index based access 
0-9

for(intialcount;condition;increment/decrement){
	//block
}

for(index=0;index<=4;index++){
	system.debug(stdid[index]);
}

for(index=0;index<=4;){
	system.debug(stdid[index]);
	index++;
}

integer index=0;
while(index<=4){
system.debug(stdid[index]);
index++;
}


enhanced for loop /for each 

for(<datatype> varaible:collection/array){
	//block 
}

u cannot process in reverse order 
we cannot get specific element 
foward cursor


integer[] stdid=new integer[5];
string[] stdname=new string[3];
system.debug(stdname);
system.debug(stdid);
stdid[0]=34;
stdid[1]=45;
stdid[2]=56;
stdid[3]=5;
stdid[4]=56;
system.debug(stdid);
system.debug(stdid[0]);
system.debug(stdid[1]);
system.debug(stdid[2]);
system.debug(stdid[3]);
system.debug(stdid[4]);
Integer studentid=stdid[2];
system.debug(studentid);
system.debug('stdid array size:::'+stdid.size());
for(Integer i=0;i<stdid.size();i++){
    system.debug('stdid['+i+']::'+stdid[i]);
}

for(Integer stdno:stdid){
    system.debug(stdno);
}

for(integer i=stdid.size()-1;i>=0;i--){
     system.debug('stdid['+i+']::'+stdid[i]);
}

array drawbacks
---------------
static memory allocation 
u cannot increase/decrese 
no much predefined function
u cannot insert/delete specific directly


wap to sum of array elements
wap to find the max of array element
wap to find the mix of array element 
wap to replace the 3rd index value and debug the array 
wap to sort the array elements 
wap to create an array with size 10 and insert new elemnt 400 in index 3 //11
wap to delete 4th index value from an array 


wap to sort the array elements 
integer[] stdarray=new integer[]{5,4,2,31};
integer temp;
system.debug('Before sorting::'+stdarray);
for(integer i=0;i<=stdarray.size()-1;i++){
    for(integer j=0;j<=stdarray.size()-1;j++){
        if(stdarray[i]<stdarray[j]){
            temp=stdarray[i];
            stdarray[i]=stdarray[j];
            stdarray[j]=temp;
        }
    }
}
system.debug('After sorting::'+stdarray);




SOBJECTS Datatypes
------------------
salesforce object 			standard controller /class
	Account                    Account
	contact						Contact
	lead							Lead
	opportunity					opportunity
	order						order
	product				product
	case					case	
	solution				solution
	campaing				campaing
	student__c					student__c
	postion__c				postion__c
	hiringmanager__c		
	
if u create an object 
	1. object (table)
	2. tab 
	3. Class/controller business llogic 
	
	insert,delete, update, undelete .... dml 
	
Account acc=new Account();
acc.firstname=uservalue
acc.lastname uservalue
acc.phone=uservalue
acc.email=uservalue
insert acc;

LEad ld=new lead();
opportunity opp=new opportunity();
hiringmanager__c hmgr=new hiringmanager__c();

Account acc=new Account();
system.debug(acc);
acc.name='infosys';
acc.phone='11111111';
system.debug(acc);

contact con=new contact();
system.debug(con);
con.lastname='kumar';
con.firstname='pawan';
con.phone='555555';
system.debug(con);

HiringManager__c hmgr=new HiringManager__c();
system.debug(hmgr);
hmgr.name__c='chiranjeevi';
system.debug(hmgr);

Account[] accountarray=new Account()[5];
Account[] accountarray=new Account[3];
system.debug(accountarray);
Account acc1=new Account();
acc1.name='charan';
acc1.phone='3234234';
system.debug(acc1);
accountarray[0]=acc1;
Account acc2=new Account();
acc2.name='kusala';
acc2.phone='3234234';
system.debug(acc2);
accountarray[1]=acc2;
system.debug(accountarray);


Contact[] conarray=new contact[3];
contact con=new contact();
con.lastname='kumar';
con.phone='123123';
conarray[0]=con;
contact con1=new contact();
con1.lastname='tatcon';
con1.phone='123123';
conarray[1]=con1;
contact con2=new contact();
con2.lastname='tatcon';
con2.phone='123123';
conarray[2]=con2;
system.debug(conarray);


public class Account{

//block
}

public class lead{

//block
}

public class hiringmanager__c{

//block

}

save
quicksave
cancel
delete
first
next
previous
last
hasprevious
hasnext


public class Account{

//members
public Id id, ownerid;

public String name,rating, industry,type,phone,fax,website,biliingcity,billingstate,billingcountry,.....etc

public datetime lastmodifeddate, createddate;

public Decimal annualrevenue;

public Boolean both_address_same__c;

.......


//member functions 

public void save(){
	//it will insert record to db and re-direct to record detail page 
}

public void cancel(){
	//it will abort your current operation
}

public void delete(){//it will the current record}

public void quicksave(){ //it will save the reocrd into the associated object and user will stay in same page}

//pagniation methods
public void next(){
	it will load the next set of records in the paginatioin
}

public void fist(){
	//it will load first set of records in pagination
}

public void previous(){

	it will load the prevois set of records
}

public void last(){
	it will load last set of records
}

public boolean hasprevious(){
	// it will return true if it is having prevous set of records in the  pagnation else ir return false 
}

public boolean hasnext(){
	//it will return true if it is having next set of record in the pagniation else it return false 
}

}



<classname> classobject=new <classname>();
Account acc=new Account();


Account acc=new Account();
acc.name='tayota';
acc.phone='234234234';
acc.active__C='yes';
system.debug(acc);
insert acc;
if(acc.id!=null){
    system.debug('account record inserted with record id::'+acc.id);
}


account - contact 
Account acc=new Account();
insert acc;
acc.name='tayota';
acc.phone='234234234';
acc.active__C='yes';
system.debug('account record inserted with record id::'+acc.id);
system.debug(acc);
if(acc!=null){
    insert acc;
}

if(acc.id!=null){
    system.debug('account record inserted with record id::'+acc.id);
}


Account acc=new Account();
acc.name='city bank';
acc.rating='hot';
acc.phone='234234';
acc.website='www.citi.com';
acc.fax='234234';
acc.active__C='yes';
acc.annualrevenue=234234;
acc.industry='banking';
if(acc!=null){
    insert acc;
    system.debug(acc);
    if(acc.id!=null){
        system.debug('account is created with recordid::'+acc.id);
    }
}


wap to insert hiringmanager__c record 

wap to build bulk records hiringmanager__c

for(integer i=1;i<=10;i++){
    hiringmanager__c hmgr=new hiringmanager__c();
    hmgr.name__C='bulkexample'+i;
    hmgr.phone__c='234234';
    hmgr.email__C=hmgr.name__c+'@awc.co.in';
    hmgr.location__C='hyd';
    insert hmgr;
    system.debug(hmgr);
}

oops 
	class 
	access modifier
associate records 


hiringmanager__c hmgr1=new hiringmanager__c();
hiringmanager__c hmgr2=new hiringmanager__c();
hiringmanager__c hmgr3=new hiringmanager__c();
hiringmanager__c hmgr4=new hiringmanager__c();
hiringmanager__c hmgr5=new hiringmanager__c();

insert hmgr1;
insert hmgr2;
insert hmgr3;
insert hmgr4;
insert hmgr5;
insert single/collection;

hiringmanager__c[] hmgrarray=new hiringmanager__c[5];
hmgrarray[0]=hmgr1;
hmgrarray[1]=hmgr2;
hmgrarray[2]=hmgr3;
hmgrarray[3]=hmgr4;
hmgrarray[4]=hmgr5;

insert hmgrarray;



oops concepts 
	structured programs
	oops 
		classes and objects 
	
properties 
	variables/members 
functionalities 
	
	
<accessspecifier> class <classname>{

	//members 
	
	//functions 
}

Accessspecifier  
	private	- within the class only 
	public - members can access within the clss and outside of the class 
	protected - within the class from all the derived class (child classes)
	global  - with the cllass with the organization and outside of the organization
		all the batch clases schedule, ....

inheritance, abstaction, polymorhism, encapsullation 

Inheritance 

public class studentdetails{
	//members 
	public string stdname;
	public integer stdno;
	public decimal gender;
	public string course;
	public string address;
}

public class productdetails{
	public string prdname;
	public string prdno;
	public datetime prdmandate;
	public datetime prdexpdate;
	public decimal unitprice;
}


object
-------
by  creating an object to the class we can access members and member functions 

<classname> objectname=new classname();

classnem objectname;
objectname=new classname;



Account acc=new Account();
contact con;
con=new contact();



public class employeedetails{
    
    public string empname,designation;
    public integer emid;
    public boolean isactive;
    public date joiningdate;
}

employeedetails empobj=new employeedetails();
system.debug(empobj);

empobj.empname='pavan';
empobj.emid=23423;
empobj.isactive=True;
empobj.joiningdate=system.today();
empobj.designation='salesforce dev';

system.debug(empobj);

system.debug('emoyeename::'+empobj.empname);
string employeename=empobj.empname;

system.debug(employeename);


mathoperations mobj=new mathoperations();
system.debug('a value::'+mobj.a);
system.debug('b value::'+mobj.b);
system.debug('c value::'+mobj.c);

//opoerations
mobj.c=mobj.a+mobj.b;
system.debug('sumresult::'+mobj.c);

mobj.a=100;
mobj.b=56;
mobj.c=4;
system.debug('a value::'+mobj.a);
system.debug('b value::'+mobj.b);
system.debug('c value::'+mobj.c);

//opoerations
mobj.c=mobj.a-mobj.b;
system.debug('sub result::'+mobj.c);


function
-----------
<accessspecifier> <returntype/datatype/void> functionname(datatype1 param1,database2 param2.....datatypen paramn){

	//body the function 
	
	return <value>;

}

returntype 
	value  - dataype of the value 
	nothing - void 

	public 
	
parameterized functions
non-parameterized functions 


function defination
function calling 


REUSABLIITY 

varlox plugin

wap to create account record and its associated contact record 
Account 
	multiple contacts 
	
	
create class account 
	use in account 
	account record with recordid
create contact class 
	contact lo reference 
	while creating the contact record we have to provide accountid=account.id 
	
	
Account accobj=new Account();
accobj.name='dell';
accobj.phone='8979';
accobj.fax='234234234';
accobj.Active__c='yes';
if(accobj!=null){
    insert accobj;
}
system.debug('account created::'+accobj);
if(accobj.id!=null){
    Contact con=new contact();
    con.lastname='dellcon1';
    con.phone='989898';
    con.accountid=accobj.id;
    if(con!=null){
        insert con;
        system.debug('contact record::'+con);
    }
}


variable - scope of the variable 
			
wap  to create hiringmanager__c records and its associate position record 

wap to create hiringmanager__c and its associated task record 


wap to create an account and it associated case 
wap to create hiringmanager__c records based on specified number


wap to create 20 lead records 
wapex class to insert 50 contacts 
wap to create hiringmanager__c and associated position records 
wap to create lead record base on specified number 
wap to insert contact based onspecified number 
wap to create account and its associated 2 contacts, 5 oppotunities 
account
	contact 2
	opportunity 5
wap to create hiringmanager__c and  its associated position and 3 associated candidate records 
hiringmanager__c
	position
		3 candidates 


Constructor
================
member function 
Constructor will get execute upon creatioin of class in memory automatic.
Constructor are used to set the default values ot the class members 

rules
	1.name should be class name
	2. always defined with  public access 
	3. does not return anything
	4. we can define one or more Constructors
	5. one Constructor can call another constructor 

public <classnmae>(){
  //logic 
}

public producthelper(){
	public producthelper(){
	
	}

}
 
wehen we create an object to the class apex compiler will create default constructor and it gets executed


types of Constructors

non-param constructor
	public class producthelper{
		public producthelper(){
		}

	}
parm constructors
	public class producthelper{
		public producthelper(integer par1,string pr2....){

		}
	}

producthelper prdobj=new producthelper();


wap to create apex class to define default constructor and assign the values to the cosustomer 



Collections 
===================
List

Set 
Map 

LIST 
------
list is a order collection which preserves the insertion order. 
homogeneous and heterogeneous elements to store
dynamic memory  allocaiton - increate and decreate the size of the list
primitive datatypes and non-primitive datatype
it allows duplicate values
syntax
List<datatype> listname=new List<datatype>();


List<Integer> stdidlist=new List<Integer>();
List<string> stdnamelist=new list<STring>();
List<Boolean> stdactivelist=new list<boolean>();
list<Id> stdrecid=new list<Id>();
List<Account> accountlist=new list<Account>();
list<Lead> leadlist=new list<lead>();
list<hiringmanager__c> hmgrlist=new list<hiringmanager__c>();



methods
---------

add 
  stdidlist.add(103);
  stdnamelist.add('pavan');

addall(<collectioni>)
	string[] stdnamearray=new string[]{'pavan','sravani'};
	stdnamelist.addall(stdnamearray);


add(position,element)
	stdidlist.add(2,55);


size()
	stdislist.size();


boolean isempty()  
	true/false

void sort()
	stdidlist.sort()

remove(index/postion)
	stdidlist.remove(4);

clear()
	stdidlist.clear();


get(position)
	stdidilist.get(2); 


set(position, element)
	it will update the new data at specified position
	stdidlist.set(2,66);


clone()
	stdnewlist=stdidlist.clone();


boolean contains(element)
	stdidlist.contains(3);


intger indexof(eleemnt)
	stdidlist.indexof(66); //2


List<String> stdnamelist=new List<String>();
system.debug(stdnamelist);
stdnamelist.add('pavan');
stdnamelist.add('sravani');
stdnamelist.add('lakshmi');
system.debug(stdnamelist);
stdnamelist.add(1,'kumar');
system.debug(stdnamelist);
system.debug(stdnamelist.size());
String[] nameary=new string[]{'ravi','kusala','hari'};
stdnamelist.addall(nameary);
system.debug(stdnamelist);

if(!stdnamelist.isempty()){
    for(integer i=0;i<stdnamelist.size();i++){
        system.debug(stdnamelist[i]);
    }
    for(String name :stdnamelist){
        system.debug(name);
    }
}

stdnamelist.add('pavan');
stdnamelist.add('ravi');
system.debug(stdnamelist);

Boolean result=stdnamelist.contains('pavan');
if(result){
   system.debug('element found'); 
}else
    system.debug('element not found');

system.debug(stdnamelist.contains('pavan'));

stdnamelist.sort();
system.debug(stdnamelist);

string name=stdnamelist.remove(2);
system.debug(name);
system.debug(stdnamelist);
//pavan

if(stdnamelist.contains('pavan')){
    integer p=stdnamelist.indexof('pavan');
    system.debug('element position::'+p);
    name=stdnamelist.remove(p);
	system.debug('element removed::'+name);
}
system.debug(stdnamelist);

SET
--------
inOrdered collection, default it will implment ascending on the elements 
it wont accept duplicate values 
dynamic, increase or decrease 
it maintains unique values 
set<datatype> setvaraible=new set<datatype>();


Note:
Apex uses a hash structure for all sets. A set is an unordered collection—you can't access a set 
element at a specific index.  You can only iterate over set element

Set<integer> stdidset=new set<integer>();
system.debug(stdidset);

stdidset.add(100);
stdidset.add(45);
stdidset.add(103);

system.debug(stdidset);

if(!stdidset.isempty()){
   
    for(Integer s:stdidset){
        system.debug(s);
    }
}

addall(collection)
remove(element)
contains(element)
clear()
equals(collection)

Map
--------
Map<datatype,datatype> mapvar=new map<datatype,datatype>();

key value pair structure 
key - unique set of values 
value - set of list type values 
dynamic memory allocation
increate or decreate 
access values by passing keys 

map<id,account> accmap=new map<id,account>();

map<accountid,contactsrecords>  ==> map<id,list<contacts>>

map<integer,string> stdmap=new map<integer,string>();

map<string,string> usercredentials=new map<string,string>();

map<id,hiringmanager__c> hmgrmap=new map<id,hiringmanager__c>();

put()
putall()
size()
isempty()
	(key) - to get the value by passing key
containskey()
remove(key)
clear()
keyset() - it will return all keys - set 
values() - it will return all values list 
equals()


Map<string,string> fruitmap=new Map<string,string>();
system.debug(fruitmap);
fruitmap.put('yellow','banana');
fruitmap.put('orange','orange');
fruitmap.put('red','apple');
fruitmap.put('green','watermalon');
fruitmap.put('yellow','papaya');
system.debug(fruitmap);
system.debug(fruitmap.keyset());
for(String color:fruitmap.keyset()){
    system.debug('Color name::'+color+'====fruitname::'+fruitmap.get(color));
    
}

if(fruitmap.containskey('red564')){
    system.debug(fruitmap.get('red'));
}else{
    system.debug('no such key');
}

fruitmap.clear();
system.debug(fruitmap);


bulkification
--------------
upon performing dml operations 



Insert onerecord/collectionrecords;

List<Candidate__c> canlist=new List<candidate__c>();
for(integer i=1;i<=151;i++){
    candidate__c can=new candidate__c();
    can.Position__c='a05GB000018skNiYAI';
    canlist.add(can);
}
if(!canlist.isempty()){
    insert canlist;
}

Wap to crate 300 contact records 
wap to craete hiringmanager__c,position__c and candidates



SOQL - salesforce object query langauage 

SELECT <COLUMN/FIELDS> FROM <OBJECTNAME> 
	[WHERE <CONDITION>]
	[GROUP BY <COLUMN NAME>]
	[HAVING <COLUMN>]
	[ORDER BY <COLUMN>]
	[LIMIT <NO.OF RECORDS TO RETURN>]
	[OFFSET <NO.OF RECORDS TO SKIP>]
	[FOR UUPDATE]
	[ALL ROWS]

limits - 100 soqls can run per transaction
never use in loop
fetch wanted/necessary fields only 

In SOQL there are four return type:

Lists<sObject>
sObject
Integar
AggregateResult

select id,name,active__C from account 
select id,firstname,lastname,email,phone from lead
select id,name,Description, Subject, Body from EmailTemplate 

write soql to fetch user detail 
select id,name,email,username from user



two types 
	static soql 
	dynamic  soql 



Static soql	
	[static soql] 
	executed automatically
	we cannot edit in runtime 

	[select id, name from account]
	[select id,lastname, email from contact]
	[select id,lastname__c,eamil__c from hiringmanager__c]


Account accrecord=[select id,name from account];  // if the query return one record 
if(accrecord!=null){
	system.debug('account id::'+accrecord.id);
	system.debug('account name::'+accrecord.name);
}


List<Account> accountlist =[select id,name from account]; // if the query returns multiple records 
if(accountlist!=nul){
	for(Account acc:accountlist){
		system.debug('account id::'+acc.id);
		system.debug('accou tname::'+acc.name);
	}
}


wap to fetch all leads 



wap to fetch all the position records and store in the map 
key,value pair 
Map<datatype,datatype>=new map<datatype,datatype>();
map<key,value> = map<id,positionrecord>

posmap<posid,posrecord>

map<key,value>

map<23423,'id,name'>

key pass 
map.keyset()
map.get(key)


wap to fetch user records and debug 
wapto fetch account records and debug
wap to fetch hiringmanager__c records and debug 
wap to fetch emailtemplates
wap to fetch al the cases in the form of map and display 
wap ot fetch all the public georups from the
wap to get all oppotunities in the form of map 


LIMIT
-----
clause is used to restrict the noof records to get returned by the soql query. it is optional.

Account acc=[select id,name from account limit 1];

wap to gecth the 5 reocrds from cotnact and sotre in map<conid,contactrecord>

ALLROWS
--------
select query will return the records from object and it will retrieve the records from 
recycilbin(deleted records)



ORDERBY clause
--------------
using this clause we can arrange the outcome from select query in an oder based on a column 

order by <column name> 
select id,name,active__c from account order by name

if we do not specify the order the default order is ascending order .

select id,name,active__c from account order by name desc 

select id,Position_Status__c, Name__c, Maxpay__c, CreatedDate from Position__c order by CreatedDate  desc


FOR update
-----------
we can apply lock on the requried record while fetching 
once transaction is completed the lock has been released automatically

select id,name from account for update



OFFSET clause
--------------
used to skip the specified noof records from the resultset 

pagenation 
OFFSET clause should eb followed by limit clause 

select id,name,email,phone, from account order by name limit 10 OFFSET 5


select columns from objectname where conditions 
1000
 calcultions 


select id,name from account where city='hyderabad'
select id,name,active__c,billingcity from account where billingcity='hyd'

select id,name,industry from account where industry='banking'

SELECT Id,Industry,Name FROM Account WHERE Industry = 'energy'

get lead status=closed converted

select id,status,lastname,phone from lead where status='closed - converted'


soql to get all hyderabad related positions 

select id,Name__c, Location__c from Position__c where Location__c ='hyd'


soql to get only deleted records from account object ..

isdeleted = true 

isdeleted = false  -- that record is not deleted

select id,name,isdeleted from account where isdeleted=true allrows 
        26 records 

soql to get opportunity whose stage is prospecting and  amount greaterthan 10k
select id,satgename,amount from opportunity where satgename='prospecting' and amount>10000


#soql to get active users who are associated to systemadmin profile 
select id,profile.name,isactive from user where isactive=true and profile.name='system admin'



LIKE Operators
--------------
fetch the similar kind of information from the obejct based on specified expressioin 

like operator should follow where clause 

select cloumns from objecname where condition like expression 

% ::  represents zero or more chanracters 
_ ::  only  one chanracter

select id,name from account where name like '%oil%'

name like 'R%'  - starts with R
name like '%kumar'  -end with kumar 
name like '_a%'              - whose name second charater a
whose name having 4 letters - name like '_____'

address 

wap to get contacts which are associated with banking industry accounts 
account - input banking - list account 
iterate accountlist 
   account - contaccts  
allcontacts


DYNAMIC SOQL
------------
select id,name from account 

String accountquery ='Select id,';

		-----
			-----
		accountquery=accountquery+'name,';
		---------
		----------
		accountquery+='email';
		------------
		-------------
		accountquery+=' from account';

DATABASE.query(); - it will return list format

List<sobject> objvar=Database.query(query);

emailname@companyname.domainame
pavan@gmail.com 
.in 


GROUP BY clause
---------------

tayota  10000
maruthi 100000
tayota  5000
tata     88998
ford     null

tayota    150000
tata      88998
maruthi    1000000



aggregate functions will take collection and return one value as result 

count() - this function returns integer value which indicates no.of records exists inside the object
count(column) - this function returns integer value, which indicates no.of values exist inside the specific column 
			Null value not be countable
count_distinct(columnname) - returns integer value, which indicates no.of values exist inside the object
			it will not count Null values and repeated values
min(columnname) - will return minimum value  
max() - will return max value 
sum() - return total of all values on specific 




AggregateResult Class
---------------------
upon using the aggregate functions inside the soql qurey the result shoubd eb of type AggregateResult class 

AggregateResult[] results=[soql query with group by clause];

we can fetch each record inside the resultset by iterating the collection 
we can fetch eaach value using Get function from resultant record 


we have to provide alias names
select industry, count(id) recordscount from account where industry='banking'


select industryh, count(id) recordscount from account group by industry;



HAVING clause
-------------
having clause is used to add one more user defined consitions along with group by clause to filter the data 

always having clause used with group by clause. having clause followed by group by.


RELATIONSHIP QUERIES
--------------------

parent to child (standard)
parent to child (custom)
child to parent (standard)
child to parent (custom )

lookupp/ master details 


Parent to child (standard releationship)
-----------------------------------------
by using this approach we can get parent record and associated child records 

[soql query (soql for child)]

select id,name from account 
(select id,name from cases)
(select id,name from opportunities)
(select id, lastname from contacts)


we an write one ormore inner quries 

Child to parent (standard releationship)
----------------------------------------
we can get data from child and relaeted parent records .

granad grand parent 
grand parent 
parent
child

like this we can traverse upto 5 levels

<parentobjectname>.<parent field> 

account .name
account.phone 

Account.owner.lastname 
account.owener.phone 


wher account.active__C='yes'
where account.owner.email='pavan@awco.in'

select id,lastname, account.name,account.owenr.lastmame from contact 




Parent to child (custom RELATIONSHIP)
--------------------------------------

__r 





DML OPERATIOONS
----------------
insert
update
delete
undelete 
upsert
merge 


150 dmls can execute 

best practise implement dml in bulk mode 
avoid inside for loop 

all dml statements are Atomic . prefomrming dml operation on collection of records, if any of the records get failed it
will rollback the whole transaction.by default each dml statement behaves like implicit transaction.



Insert accoutnrec;
Insert accountlist;


Database Class
--------------
we can execute your dml statements as non-Atomic or partial processing .

readymade methods 


Database.insert() methods
-------------------------
this method to insert one or more records
Database.insert(collectionname);
this method will act as insert statement.

Database.SAveresult[] <object>=Database.insert(collecitonname,Boolean Allornothing);
	True - it performs like atomic 
	False - it performs like non-atomic/partial processing 


Boolean isuccess() - True,false 
Id getid()
geterrors()

Database.Error[] errors =object.geterrors();

getmesage()
getstatuscode()
getfields()




delete operations
-------------------
Delete collectionname /record;

Database.deleteresult[] results=Database.delete(collection,True/false);


undelete
-------------

used to restore the records fromrecyclebin . we canfetch records from the object 'isdeleted' field 

undelete single recoord/collection;

Database.Undeleteresult[] results =database.undlete(collection,True/false);


UPDATE statement
-----------------
1.  get the records which needs to be changed
2. change the values in wanted fields 
3. update operation 

cross check 
4. get the records based on the new values 
5. if records exists update is success 



update record/collection;



wap to assign all the unassociated contacts to specific account 
wap to change lead status to 'closed - converted ' which are having annualrevenue >2000000
wap to change the ownership of the accounts to 'user2' which are energy industry 
wap to insert 450 leads by implementing paretial processing 
wap to delete the contaect records which are created in last week
wap to remove, all contacts which are not associated with any account record
wap to delete all the hiringmanagers whose emailid starts with 'test'
wap to restore the hiringmanager records whose locatioin is hyd 
wap to print the accountids whose contacts count > 10 
wap to synchoronize the fax,phone,email of contacts with associated account 



upsert statement
-----------------
update + insert  
id, new records (which are not comitted)

upsert record/collections;

database.upsertresult[] results=database.upsert(collection,true/false);

  boolean iscreated() 
  true - reocrd created 
  false - record updated 

MERGE 
--------
to combile multiple records  into single records 

merge operation can be done on account/contact/lead 

upto 3 records we can merge 

merge <target/parent> source/child;

merge ac1 ac2;  // ac2 infor will save to ac1 and ac2 will removed fromobject 




SOSL
salesforce objecname search langauage

FIND 'searchtext' IN ALL FIELDS RETURNING 
	<OBJECTNAME>(FIELD,FIE....FIELD),
	<OBJECTNAME>(FIELD,FIELD,.....FILED),

	....................................
	<OBJECTNAME N>(FIELD.....)



	EXAMPLE
	 FIND "test" IN ALL FIELDS RETURNING 
	 	Account(name,email,industry),
		Contact(lastname,fiestname,email),
		position__c(name__c,Description),
		Lead(latname,firstname,email),
		candidate__c(lastname,firstanme,email)


	20 sosl quries
	each sosl can process 2000 records as the result 
	each sosl can search max of 20 objects 


	we cannot perform dml ooperations on sosl query result.


	static and dynamic 

	STatic 
	---------
	should be enclosed in[]
	serachtext cannot be dynamic 
	automatically executed 

	return in the form List<List<sobject>> = [];


	Dynamic sosl 
	-------------
 we can prepare the sosl query dynamically.
 it means we will add dynamic searchtext in sosl query  at runtime

 String searchquery ='sosl query';

 Search.query(); - also reutrn List<List<sobject>> =Search.query(searchquery);


 upon searching in multiple objects, we can search in search group.

 IN ALL FIELDS - it will serach in all the fileds o the object
 IN NAME FILEDS - IT WILL SERACH IN NAME FILEDS 
 IN EMAIL FIELDS - it will serach  in fields iwth wmail fileds 
IN PHONE FILEDS - it will serach in phone keyword fields 


query editor 
apex programs 

object - "Allow search" 

EMAIL PROGRAMMING
-----------------

in single transaction we can send max 10 email 
	Messaging.sendemail() 


single email

Messaging.singlemailmessage class 
 by using this class we can sedn the emal notification one ormore receipents dynamically  at runtime. with required informaiotn 

 Messaging.SingleemailMessage emailobject=new Messaging.SingleEmailMessage();

 setToAddress(collection)
 Setccaddress(collection)
 setbccaddress(collection)
 setreplyto(string replytoemailid)
 setsenddisplayname(string sendername);
 setsubject(string subjectstring)
 setplaintextbody(string bodystring)
 sethtmlbody(string htmlbodystring);


Messaging.Sendemail(new Messaging.SingleemailMessage[]{emailobject});
Messaging.sendemail(List<Messaging.singleemailmessage>);







wap to send emal notification when an update on account 
wap to send email notification when an delete contact 

wap to send the email notification to all contact peple whose records are not updated with therir account details 


Messaging.Massemailmessage 
 recordids 
 allow us to send email notification using email templates 

 settargetobjectids(listofids);
 settemplateid(templateid);


list of records =[query]
List<id> conids=new list<id>();
for(contact con:listofrecords){
	system.debug(con.id);
	conids.add(con.id);
}

settargetobjectids(conids);


ASYNCHRONOUS PROGRAMMING
------------------------

Batch apex PROGRAMMING
schedule apex PROGRAMMING
future methods
queueable apex 
flex queues 


BATCH PROGRAMMING
-----------------
we can do DMl operations on bulk records at a time 
it allows to process 50 milliion records 
batch apex job will executed outside of the salesforce organization by using salesforce resources.

allthe batch classes should be declared as Global accesss specifier 

a+b 

Database.Batchable<sobject> 

a+b

your batch class should be implement this Database.Batchable<sobject> interface 

implement - inheritance concept , we are inheriting the methods from batchable class.

Global class <classname> implements Database.batchable<sobject>{

	//business logic 
	//give the defination of batchable interface  methods

}

Batchable interface methods  :: start, execute, finish
---------------------------
Global Database.Querylocator start(Database.batchablecontext bcontext):

  start - is interface methods, it will execute only ont time at the starting of the batch class execution.
  this method is used to execute the soql query, to get the records .

	in order to get 50 millin records we need execute soql query using Database.getquerylocator();

String query='select id, name from account';
Database.getquerylocator(query);

this getquerylocator executes your query and store the reault in buffer memeory and return the address location to 
database.Querylocator.

Database.Querylocator class will get the all the reocrds divide the records into batches.

each batch canhave mac 1-2000 abd default size is 200

start() method will get each batch records from thebuffer memory and  pass the reocrds to  execute() method for processing


EXECUTE()
Global void Execute(Database.batchablecontext bcontext, list<sobject> recordstoprocess)

this method recieves the data from start method and perform your required business logic.
we can implment dml operations  on the records 
once the batch of trecords has been processed, then it will indicates to start() methods to provide the next batch records 

this process will be continued till all the batches will get executes.

each batch recorsds, will be trated as a discrete trtansaction. so that failue of one batch will not affect of other 
batch records.


Global Void Finish(Database.batchablecontext bcontext)
	consolding report , email, logging 
	it will execute only once 

	once all batches has been executed the finish method will get exeuctes to perform post-execution logic,like 
	sending email notifcations... 


note: all the batch job details, will get tracked by using Asyncapexjob 

we have query to Asyncapexjob object to get ehte deatils of required job using job id.

Asyncapexjob jobdettails=[select id, status, totaljobiems, process, createdby.email from  Asyncapexjob
							where id=<batch job id>];


u can execute the batch in all the below places
Triggers
schedule
anonymoous window
another batch job 
vf pages 

id batchjobid=DAtabase.executebatch(<batchclassobjecname>);  // default 200

id batchjobid=DAtabase.executebatch(<batchclassobjecname>,integer size(1-2000));


how to execute batch job from anonymoous windows.
updateaccountsbatch obj=new updateaccountsbatch();
Database.executebatch(obj,2);



dear customer,

here is the batch job status notification :: jobname
job id :: jobid 
job status ::
job no.of batches :: 
no.of batches processed :: 
no.of error ::

we can write custom functions in batch class . but not good practise.

Database.stateful

100
account - amount 
50 batch1
execute {totalamount = toatal+acc.amount}


batch2 50 
execute {totalamount = toatal+acc.amount}


totalamount

global with sharing class calculateTotalRevenueBatch implements database.Batchable<sobject>,Database.stateful {

	start
	execute
	finish
}

 Number of SOQL queries: 0 out of 100
  Number of query rows: 0 out of 50000
  Number of SOSL queries: 0 out of 20
  Number of DML statements: 0 out of 150
  Number of Publish Immediate DML: 0 out of 150
  Number of DML rows: 0 out of 10000
  Maximum CPU time: 0 out of 10000
  Maximum heap size: 0 out of 6000000
  Number of callouts: 0 out of 100
  Number of Email Invocations: 0 out of 10
  Number of future calls: 0 out of 50
  Number of queueable jobs added to the queue: 0 out of 50
  Number of Mobile Apex push calls: 0 out of 10

Governor limits of batch class
-------------------------------
up to five active batch jobs can be allowed for apex.

maximumm can deal 50 milliion records , database.Querylocator, database.getquerylocator

every batch job size maximum 2000

if no size menthied default size is 200

apex Governor limits are reset for each execution of execute method

the start, execute and finish methods can implement upto 10 callouts each 

maximum no.of batch executions is 250000 per 24 hours 



SCHEDULE APEX PROGRAMMING
-------------------------


System.schedulable 

Execute- this method has to define in your schedulable class 


Global class annualrevenue implements system.schedulable
{
  //business

  global void execute(database.schedulablecontext scontext){
	//business logic 
		//can run batch program 
		updateaccountsbatch obj=new updateaccountsbatch();
		database.executebatch(obj,50);
  }

}


schedule a job 
--------------


FUTURE methods
---------------

there are two types objects 

setup objects 
	setup object is one that must be edited from the setup or builder area of the plastform
	these objects help us to interact metadata for declarative development 

example, user, userrole, userterritory, territoryoupmember, recordype,profile, queueobjece, custommetdata,...

non-setup objects 
	standard object 
	custom object 
	account, contact, position__c, hiringmanager__c....


Use case 
--------
try to perform dml operatioin on both setup and non-setup object in signle transaction.

MIXED DML OPERATION  exception

@FUTURE  annotation , to execute your logic ASYNCHRONOUSly

webservice callouts 

future methods run background 

u can define the future method which takes long time 

each future method queued and then executes

Rules 
---------
method should be static 
return type should be void 
future method parameters must be primitive datatypes, like arrays, string , collectioins [primitive dtypes]

we cannot pass sobject types 

we cannot calll one future method from another future method 

maximum no.of future methods  can call 250000 in 24 hours 



FLEX QUEUES IN salesforce
--------------------------

5 batch jobs we can run simultaniously

holding 
queued

spring 15 ..

100 additional batch jobs for execution 



Queeable apex 
-------------

winter 15, queueable interface

this interface hellp u to add jobs to the queue and monitor them. which is enhanced way of running ASYNCHRONOUS apex code compared
to future method 

we will get higher Governor limits than sysnchrounous apex... heap size 

apex job heap size - 6mb 
Asyncapexjob - 12mb 
no.of soql - 200

public class <claaname> implements queueable {

	publlic void execute(system.queueablecontext qc){
		//dml 
	}

}


Id  jobid = system.enqueueable(new classname());


future vs queueable 
-------------------

both jobs will run when resources avalable
both job can be queued

-->one future mehtod  in a class , where as we can make entire class as queueable 
-->future method does not return id, where as queueable return the jobid 
-->future method does not allows sobjects types , queueable can contain primitive and non-primitive
-->chaining jobs 
	--u can chain one job to another job by staring one from another 


Queueable apex limits 
----------------------
	u can add upt to 50 jobs to the queue with system.enqueuejob in a signle transaction
	no limit in chaining jobs 
	u cannot call multiple chiilds from one parent queueable job 


queueable job1
	job2
		job3 
			job4
				job5



APEX Triggers
-------------
Trigger are custom logic will get fire automatically upon perform the DML operation on an object 


validation rules 

trigger can fire before and after performaing the dml oepration

events 
Before Insert, after insert
before update,after update
before Delete,after delete
after undelete 

Triggers runs ASYNCHRONOUS 

each trigger associated with an object 



Trigger <triggername> on <object name>(events list){
	
	// logic 

}


Trigger Leadtrigger on Lead (Before insert){

	//lgoic
}


Trigger hiringmanagertrigger on hiringmanager__c(before insert,after delete){
	
	//logic belongs to before insert operation 

	// logic belongs to after delte operation 

}


Trigger opptytrigger on opportunity(Before insert, after insert, before update, after udpate, before delete, 
after delete, after undelete){

	//logic 

}

oppty record 
	discount > 7% and owner is pavan 

	automatically send it for approval 



Trigger context variables 
--------------------------

Boolean Trigger.isinsert 
boolean Trigger.isupdate
boolean trigger.isdeleted
boolean  Trigger.isundelete
boolean Trigger.isbefore
boolean Trigger.isafter 

Trigger accounttrigger on Account(Before insert, after insert, before delete, after undelete){

	if(Trigger.isinsert && Trigger.isbefore){

		//before insert logic
	}

	if(Trigger.isdelete && Trigger.isbefore){
		//before delete logic 

	}

	if(Trigger.isundelete && trigger.is after){

		//after undelete lgoic 
	}

}


each trigger associated with one object , but an object can  have multiple triggers 





Trigger accounttrigger1 on Account(Before insert, after insert, before delete, after undelete){

	if(Trigger.isinsert && Trigger.isbefore){

		//before insert logic
	}

	if(Trigger.isdelete && Trigger.isbefore){
		//before delete logic 

	}

	if(Trigger.isundelete && trigger.is after){

		//after undelete lgoic 
	}

}

best practise
	write one trigger for one object 
	use context variables to avoid repeat execution of your logic 
	code less triggers , write the business logic in classes not in triggers 


Trigger.New - 
list collection which contains the current context records. it will hold the newly inserting records 
List<sobject> Trigger.new 
		This is available in both Insert and update operations 
		this is not available for Delete operations 


Trigger.Old
	list collection, it holds previous context records, with old values .

		list<sobject Trigger.old 

			this is available in delte and update operations 
			this is not available in insert operaiton
Trigger.oldmap
	map collection which holds the old/previous context records.
	key	- id 
	value  - record 
	is available in update and delete operations 

Trigger.newmap 
	key 	- id 
	value  - record 
   this collection is available in after insert and update operationis 
   this is not available in before insert 



Trigger accounttrigger on Trigger (before insert){

	///rating = hot 

	if(Trigger.isinsert && Trigger.isbefore){
		//which record have to  rating to hot 
		for(Account acc:Trigger.new){
			acc.rating='hot'
		}
	}
}	

1. When ever new Account is inserted with Industry as 'Banking ' then set the phone as '888'
2. 2. When ever new lead is created , calculate the leadscore using before
inserting
Field Name NOT NULL NULL
Email 10 0
Phone 10 0
Industry 20 0
Note : First Create a custom field LeadScore on Lead object
3. Create a Queue on Lead object as Banking Queue with users ( satish) :
Create a Queue on Lead object as Energy Queue with Users
Scenario: When a new Lead is inserted based on the industry field value
assign it
corresponding queue
IndustryBankingassing
owner of the record as Banking queue
IndustryEnergyAssign
owner of the record as Energy Queue
Industry other than Banking and Energy user who ever has
created the
record he should be the owner
4.When ever new Account is created with AnnualReneue more than 50
Lacs and Industry
as Energy then create a new opportunity for this account with
OpportunityName as AccountName
StageName as Prospecting
CloseDate as Today+30 days
5. When ever new opportuntiy is created with StageName as 'closed Won '
then
add karthic as OpportunityTeamMember
OpportunityTeamMember :
OpportunityId :
UserId :
OpportunityAccessLevel :
TeamMemberRole
6.When ever new Account record is created with Account Type as
'prospect ' then
create a new contact for this account with following data
Contact lastname as Account Name
COntact Phone as Account Phone
7. When ever a new Opportunity is created with stageName 'closed won'
share the record
with user karthic
8. when ever new Case is created with Priority as 'High' and origin as
'Email'
then share the record with karthic with edit permission
9. When ever the phone no of the account is modified then set
corresponding contacts
homephone as new Phone no of Acctount
otherPhone as Old Phone no of Account
10. Create a Following Custom Fields on Account Object :
Field Name DataType
Total_
Amount Currency
PipeLine_Amount Currency
Won_Amount Currency
Lost_Amount Currency
Scenario 1: When a new Opportunity record is created for an account
rollup the opportunity amount to Corresponding Account
1. If new Opportunity Stage is Close Won then add the amount to
Account 's
Total_Amount=Total_Amount+Opportunity Amount
Won_Amount=Won_Amoutn+Opportuntiy amount
2. If new Opportunity stage is closed Lost then add the amount to
Accounts
Total_Amount=Total_Amount+Opportunity Amount
Lost_Amount=Lost_Amoutn+Opportuntiy amount
3. If new Opportunity stage is not closed Lost or closed won then add
the amount to Accounts
Total_Amount=Total_Amount+Opportunity Amount
PipeLine_Amount=PipeLine_Amount+Opportuntiy amount
Scenario 2: When a existing opportunity stage is modified to closed won or
closed lost
then
1. If stageName is modified to Closed won
Remove the amount from PipleLine_Amount and add it to
WOn_Amount
2. If StageName is modified to Closed Lost
Remove the amount from PipleLine_Amount and add it
Lost_Amount


create a trigger on account object to assign the annualrevenue value as below 
industry name 				annualrevenue
-------------------------------------------
Banking						8000000000
finance						7000000000
insurance					6000000000
healthcare					5000000000
else						40000000

new account record / update 


object : Account 
type :  before insert, before update

after insert --> fetch record , chek industry type then set value , update 



-->
Create a trigger to make user each contact shouldbe getssociated with an account 
u can make account field (lookup relationship field)  this as mandatory 
u can write validation rule
u can create a flow / trigger 

Object : Contact 
Type : before update, before insert
Collection : Trigger.New 


-->
orphan contacts assign to some account 


-->
careate a triigger to preventhe deletion of an active account record 

validation
flow
trigger 

object :account
event : Delete 
type :  before 
Collection : Trigger.old 



-->
write a trigger to prevent the dupicate candidate records on candidate__c object 

object : candidate__c
event : update, insert 
type : before
collection : Trigger.new 


--> wat to prevent the deletion of the associated contacts upon removing the account record 

object :account 
event : delete 
type : before 
collection : Trigger.old 
action :
  accountid
   remove account information from the associated contacts 
   select



-->
wat to synchoronize the contact record's phone and fax values with the associated account records phone and fax values 

object - Account 
event - update
type - After
collection - Trigger.New, trigger.newmap
action - 
	set the accounts phone and fax values to associated contacts 

   1. account records , new, newmap 
   2. fetch contact records 
   3. set values 
   4. update contacts 

-->
BULK LEAD CONVERSION
--------------------
upon lead convertion, we have to click convert button which presents onlead record 
bulk lead convertion no such process

appexchange - products 
write own apex code 


Class - Database.leadconvert 

this class is used to hold the lead record, which needs to get converted. we have to create object to this class 


Database.leadconvert lconvert=new Datbase.leadconvert();

list<datbase.leadconvert> listldconvert=new list<database.leadconvert>();


Methods:
--------
setleadid(leadrecordid): this method is use to specify the lead record id which needs to get converted.
lconvert.setleadid(asdf08908asdf);

setsendnotificationemail(boolean): notification to lead owner
True - send email
flase - no notification 


setdonotcreateopportunity(boolean):
 True - do not create
 false - crate opty 

 lconvert.setdonotcreateopportunity(flase);

 setconvertedstatus(status):
 this method is used to assign thestatus for the lead record upon convertion
 we have to collect the leadstatus value from leadstatus object 

 leadstatus statusrec=[select id,masterlable,isconverted from leadstatus where isconverted=true limit 1];
 if(status!=null)
	lconvert.setconvertedstatus(statusrec.masterlable);


Database.convertlead(list<datbase.leadconvet>)
database.leadconvertresult[] results=database.convertlead(list of leads to convert);



triggers
object : LEad
event : update/insert
type : after 


-->
Write a trigger on the Contact object to prevent 
inserting a new contact with the same First Name and Email for the same Account.
Trigger ContactTrigger on contact(Before Insert){

    set<ID> accountidset=new Set<id>();
    for(Contact con:Trigger.New){
        accountidset.add(con.accountid);
    }
    List<Contact> contactexistedlist=[Select id,firstname,email,accountid from Contact where accountid in accountidset];

    for(Contact con:Trigger.NEw){
        if(contactexistedlist.contains(con.firstname) && contactexistedlist.contains(con.email)){
            //send email
            con.firstname.adderror('with this name already existed');
        }
    }
    
}

--> 
Write a batch to update all Contact records with a custom field "Preferred Contact Method" set to 
"Email" if they have opted for email communication (Email_Opt_In__c = true)
Gobal class updatecontactBatch implements Database.batchable{

    global Database.querylocator start(Database.batchablecontext bc){
        STring contactquery='select id,email,preferred_contact_method__c,Email_Opt_In__c from contact';
        return database.getquerylocator(contactquery);
    }

    global void execute(database.batchablecontext bc, list<contact> contactstoupdate){
        for(contact con:contactstoudpate){
            if(Email_Opt_In__c){
                con.preferred_contact_method__c='Email';
            }
        }
        update contactstoudpate;

        or // database.saveresults[] resuts= database.udpate(contactstoupdate,false);
    }

    global void finish(database.batchablecontext bc){
        // post bacth action
    }



}

-->
Query Contacts that have Opportunities with a closed date in the last 30 days 
and whose Account is located in a specific country (e.g., "United States").


account - > contact -> oppty 

select  id,accountid.country, (select id,closeddate from opportunity where closeddate in last_n_Days 30)  from contact where accountid.country='US'


-->
Write a SOQL query that returns all the account IDs where there are no related contacts.

select id from account where id not in  (select id, accountid from contact) 


CUSTOM SETTINGS IN APEX
-----------------------
stores in application cache 
		no limits 


List custom setting 
	organization wide static data store 
	this cannot access in fromula fields 
hierarchy custom setting 
	we cn store profile/user specific data
	we can access in formulla fileds 
$setup.<cstomsettingname>.fieldname 


without writing query we can get custom settings 
10mb

we can create upto 300 fields 


getall()
getinstance(customsettingrecordname)
getvalues(customsettingkeyname)

Map<string,ROR__mdt> mapregions=ROR__mdt.getall();
system.debug(mapregions.size());
system.debug(ROR__mdt.getall().values());




Recursive Triggers 
-------------------



best practise in writing triggers 
----------------------------------
1. trigger should handle bulk , use for lop to process records 
2. always check nulll pointer exception
3.  excepton handling , try catch blocks
4. use context variables to separate trigger logic 
5. do not use dml in for loop
6. do soql sosl inside loops 
7. proper test classes 
8. code less triggers 
9. avoid recursive triggers by adding proper conditions 
10. Maintain only one trigger for each object 



sequence of execution /Order of executioin 
------------------------------------------
1. Load 
2. System validations 
3. Before triggers 
4. custom validations 
5. duplicate rulles
6. save / no commit to db 
7. AFter triggers
8. Assignment rules
9. Autoresponse rules
10. workflows
11. updaterecord 
12. procss buliders ,flows 
13. escalation rules
14. entitlement rules 
15. parent roll-up summaries 
16. grand parent rollup summaries
17 criteria based sharing rules
18. datbase commit 
19. post commit logics 


Exception handling 
------------------

apex code 
errors
	complie time errors 
		syntax errors 
		due to lack of system resources
	run time errors 
		upon executin your apex code we will get this errors. Exceptions 

because of this exceptions program will terminate abnormally. 
	debug logs 
	error objects 
	email notification


System defined exceptions 
	listexception
	limitexception
	dmlexception
	arrayindexoutofboundexeption
	math exception 
	queryexception
	calloutexceptpion
	filenotfoundexception
	nullpointerexception..............etc 

account acc=new accoun();
insert acc	; //dml exception

account acc=[select * from account]; // query exception 

string s;
system.debug(s.cointains('asdf')); // nullpointer exception


234234/0  - mathexceptions 

list<string> lcities=new list<string>{'ap','tn'};

lcities[2]; // 


try block -  business logic 

catch block - 

finally block - cleanup all memory.
try - finally 
catch- finally .
finally block always executes 

Exception class - 

try {

		business logic 
}
catch(list exception calss type ){

}
catch(dml exception calss type ){

}
catch(query exception calss type ){

}
finally{
}
Try block must have at least one catch block or a finally block

custom exceptions 
-----------------
public claaname extends exception{
	//you will use custom exeption

}


public myexception extends exceptioin{
	//logic 
}

custom exceptions are used to display the custom error messages 



TEST CLASSES FOR UNIT TESTING
-----------------------------
dev   (unit testing)
a+b 
test class (unit testing)
  inputs 
  a+b
  result 
  manual comparison 

testing   (uat, performac....)
a+b 
TEST class  (optional)



produtioin (live)
a+b 
test class 


your test class coverage >=75% 


apex class 
vf controller classes 
triggers
batch andschedule 
webservices & apis 



Classname - mathoperations 
test class name -  mathoperationsTest 


classname - Accounthandler
test class name - Testaccounthandler 


classname - Positionhelper
test class name - Test_positionhelper

classname - hiringmanagerhelper
test class name - hiringmanagerhelper__Test 


@isTest 
<private/public> class <testclasasnme>{
	//logic 

}



@istest 
public class Test_positionhelper{

   // logic 

}

we have to prepare testmethod inside the testclass which will indicate the starting point of the application testing 

test method alwasy static 
test method does not return any value (use void return type)
test method should be defined with keyword "testmethod"
we can  call normal methods from test methods 


public static testmethod void <methodname>(){
	//logic for testing 

}




@istest
public class hiringmanagerhelper__Test{

	static testmethod void hiringmanagertest(){

		  // we will craeted recordsv 

		  // will validate records been created ornot 
	}
}


@isTest(SeeAllData=true)
  